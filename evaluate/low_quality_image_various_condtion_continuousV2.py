import numpy as np
import os
from data_process.utils import logP, QED, weight, SA, TPSA, get_mol,HBD, HBA, Rotatable
from tqdm import tqdm
import pandas as pd


def property_interval_determine():
    logp_interval = {"min": -2, "max": 7}
    qed_interval = {"min": 0.15, "max": 1}
    sa_interval = {"min": 1.5, "max": 4}
    molwt_interval = {"min": 150, "max": 600}
    tpsa_interval = {"min": 0, "max": 150}
    hbd_interval = {"min": 0, "max": 5}
    hba_interval = {"min": 0, "max":10}
    rotatable_interval = {"min": 0, "max": 10}

    property_interval_dict = {"Logp": logp_interval,
                              "QED": qed_interval,
                              "SA": sa_interval,
                              "MolWt": molwt_interval,
                              "TPSA": tpsa_interval,
                              "HBD": hbd_interval,
                              "HBA": hba_interval,
                              "rotatable": rotatable_interval
                              }
    return property_interval_dict


def build_dict():
    cond_dict = {}
    cond_dict["invalid_mol"] = 0
    cond_dict["valid_mol"] = 1
    cond_dict["None_valid_mol"] = 2
    cond_dict["unmatched_property"] = 3
    cond_dict["matched_property"] = 4
    cond_dict["None_property"] = 5
    cond_dict["None_logp"] = 6
    cond_dict["None_QED"] = 7
    cond_dict["None_SA"] = 8
    cond_dict["None_TPSA"] = 9
    cond_dict["None_MolWt"] = 10
    cond_dict["None_HBD"] = 11
    cond_dict["None_HBA"] = 12
    cond_dict["None_rotatable"] = 13
    cond_dict_valuetoname = {value: key for key, value in cond_dict.items()}
    return cond_dict, cond_dict_valuetoname


def property_match(property_value, property_setting, property_min, property_max, scale=0.2):
    legal_range_len = (property_max - property_min) * scale
    if property_setting - legal_range_len <= property_value <= property_setting + legal_range_len:
        return True
    return False


def main():
    path_ori = [
    # detail the images_path generated by the by model
    ]

    all = []
    for path in path_ori:
        all.append(pd.read_csv(path))

    all = pd.concat(all).reset_index(drop=True)

    save_to_dir = path_ori[0].split("/image_path")[0]

    print("Total number of data:", len(all))

    property_interval_dict = property_interval_determine()
    invalid_property_dict = [True] * 8
    cond_dict, cond_dict_valuetoname = build_dict()

    target_path_csv = []

    error_invalid_mol = 0
    error_over_sa = 0
    error_property = 0
    violate_list_each_property = np.array([0] * 8)
    all_setting_each_property = np.array([0] * 8)
    valid_row_index = []
    with tqdm(total=len(all)) as pbar:
        for index, row in all.iterrows():
            pbar.update(1)
            cur_mol = get_mol(row["SMILES"])

            if cur_mol == None or pd.isna(cur_mol):
                target_path_csv.append([row["image_path"],
                                        row["SMILES"],
                                        cond_dict["None_property"],
                                        cond_dict["None_logp"],
                                        cond_dict["None_QED"],
                                        cond_dict["None_SA"],
                                        cond_dict["None_MolWt"],
                                        cond_dict["None_TPSA"],
                                        cond_dict["None_HBD"],
                                        cond_dict["None_HBA"],
                                        cond_dict["None_rotatable"]
                                        ] + invalid_property_dict)
                error_invalid_mol += 1
                continue

            # if 'molscribe_score' in all.columns:
            #     if row["molscribe_score"] < 0.85:
            #         # This threshold will inevitably classify some molecular images
            #         # that appear completely normal to humans as invalid molecules.
            #         # Particularly, molscribe has low confidence scores for many structurally simple molecules.
            #         # Therefore, after completing model training (for property-based molecular design), this part needs to be commented out.
            #         error_invalid_mol += 1
            #         if weight(cur_mol) < 366:
            #         # Due to molscribe's recognition ability, molecular images of low molecular weight are skipped.
            #             continue
            #         else:
            #             target_path_csv.append([row["image_path"],
            #                                 row["SMILES"],
            #                                 cond_dict["None_property"],
            #                                 cond_dict["None_logp"],
            #                                 cond_dict["None_QED"],
            #                                 cond_dict["None_SA"],
            #                                 cond_dict["None_MolWt"],
            #                                 cond_dict["None_TPSA"],
            #                                 cond_dict["None_HBD"],
            #                                 cond_dict["None_HBA"],
            #                                 cond_dict["None_rotatable"]
            #                                 ] + invalid_property_dict)
            #             continue

            cur_avilable_property_dict = {"TPSA": TPSA, "SA": SA, "Logp": logP,
                                          "QED": QED, "MolWt": weight,
                                          "HBD": HBD,
                                          "HBA": HBA,
                                          "rotatable": Rotatable
                                          }
            cur_mol_property_result = {key: cur_avilable_property_dict[key](cur_mol)
                                       for key in cur_avilable_property_dict.keys()}

            # if cur_mol_property_result["SA"] > 5 or cur_mol_property_result["MolWt"] > 800:
            # this will affect model performance for conditional generation especially for large molecular images
            # but it can improve the performance of unconditional generation
            #     target_path_csv.append([row["image_path"],
            #                             row["SMILES"],
            #                             cond_dict["None_property"],
            #                             cond_dict["None_logp"],
            #                             cond_dict["None_QED"],
            #                             cond_dict["None_SA"],
            #                             cond_dict["None_MolWt"],
            #                             cond_dict["None_TPSA"],
            #                             cond_dict["None_HBD"],
            #                             cond_dict["None_HBA"],
            #                             cond_dict["None_rotatable"]
            #                             ] + invalid_property_dict)
            #     error_over_sa += 1
            #     continue

            mol_setting = [
                row["logp_setting"],
                row["QED_setting"],
                row["SA_setting"],
                row["MolWt_setting"],
                row["TPSA_setting"],
                row["HBD_setting"],
                row["HBA_setting"],
                row["rotatable_setting"]
            ]
            mol_setting_dict = [
                row["logp_None"],
                row["QED_None"],
                row["SA_None"],
                row["MolWt_None"],
                row["TPSA_None"],
                row["HBD_None"],
                row["HBA_None"],
                row["rotatable_None"]
            ]
            available_property_list = ["Logp", "QED", "SA", "MolWt", "TPSA", "HBD", "HBA", "rotatable"]

            violate_count = 0
            for label_index in range(len(mol_setting)):
                if mol_setting_dict[label_index]:
                    continue
                all_setting_each_property[label_index] += 1
                if not property_match(
                        cur_mol_property_result[available_property_list[label_index]],
                        mol_setting[label_index],
                        property_min=property_interval_dict[available_property_list[label_index]]["min"],
                        property_max=property_interval_dict[available_property_list[label_index]]["max"],
                ):
                    violate_count += 1
                    violate_list_each_property[label_index] += 1


            if violate_count > 0:
                error_property += 1
                if row["molscribe_score"] > 0.9:
                    target_path_csv.append([row["image_path"],
                                        row["SMILES"],
                                        cond_dict["unmatched_property"]] + mol_setting + mol_setting_dict)
            else:
                valid_row_index.append(index)


    print("all imqualified image rate:", (error_property + error_invalid_mol) / len(all) * 100, "%")
    print("error_invalid_mol:", error_invalid_mol / len(all) * 100, "%")
    # print("error_over_sa:", error_over_sa / len(target_path_csv) * 100, "%")
    print("umatch_property_images:",
          (error_property) / len(all) * 100, "%")
    for i in range(len(all_setting_each_property)):
        if all_setting_each_property[i] == 0:
            all_setting_each_property[i] = 1
    print("unmatch_each_property:", violate_list_each_property / all_setting_each_property)
    print("success_rate in valid image:", (len(valid_row_index) / (len(all)-error_invalid_mol)) * 100, "%")

    # save inqualified images csv
    pd.DataFrame(target_path_csv, columns=["image_path", "SMILES", "property_match", "aLogP_label",
                                               "QED_label", "SAscore_label", "TPSA_label", "MolWt_label",
                                               "HBD_label", "HBA_label", "rotatable_label",
                                               "aLogP_label_None", "QED_label_None", "SAscore_label_None",
                                                "TPSA_label_None", "MolWt_label_None",
                                               "HBD_label_None", "HBA_label_None",
                                               "rotatable_label_None"]).to_csv(os.path.join(save_to_dir, "initial_low_quality_invalid_path.csv"), index=False)
    print("save to ", os.path.join(save_to_dir, "initial_low_quality_invalid_path.csv"))

    # save qualified images csv
    # all_valid = all.loc[valid_row_index]
    # all_valid.to_csv(os.path.join(save_to_dir, "successful_case.csv"), index=False)
    # all_valid = all_valid[all_valid['molscribe_score'] > 0.9]
    # all_valid.to_csv(os.path.join(save_to_dir, "initial_high_quality_successful_case.csv"), index=False)


    print("done")
    # print("all type invalid len:", len(target_path_csv))


# for standard moses data
# python pre_plot.py --path_gen ...
if __name__ == '__main__':
    main()
